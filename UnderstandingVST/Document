//readind Plugin

inClass: MrsWatson
{
	result   = buildPluginChain(pluginChain, programOptionsGetString(programOptions, OPTION_PLUGIN), pluginSearchRoot)
	//ReturnCode            //PluginChain (*),  //PluginName (ex: Oud.dll)

	builPluginChain:
		pluginChainAddFromArgumentString(pluginChain, String, searchRoot)
		//Construct pluginChain in pointer pluginChain

	pluginChainAddFromArgumentString:
	inClass: PluginChain
	{
		function: pluginChainAddFromArgumentString(PluginChain, CharString, CharString)
		// Expect a semicolon-separated string of plugins with comma separators for preset names
        // Example: plugin1,preset1name;plugin2,preset2name


        //without preset
        plugin = pluginFactory(pluginNameBuffer, searchpath)
        inClass: Plugin
        {
        	function: pluginFactory(pluginName, pluginRoot)
        	return newPluginVst2x(pluginName, pluginRoot)
        	inClass: PluginVst2x
        	{
        		//Create a plugin, and setting parameters,
        		//plugin Name mainly, and other functions

        		//openPlugin=_openVst2xPlugin
        		//processAudio=_processAudioVst2xPlugin
        		//processMidiEvents=_processMidiEventsVst2xPlugin
        		// extraData of type void * (PluginVst2xData) that contain the AEffect
        		...
        	}

        }

        pluginChainAppend(pluginChain, plugin, preset)
        openPlugin(plugin)
        inClass: Plugin
        {
        	function: self->openPlugin(self) //self is plugin
        	// openPlugin = _openVst2xPlugin
        	inClass: PluginVst2x
        	{
        		// we declare, AEffect *pluginHandle;
        		data->libraryHandle=getLibraryHandleForPlugin(plugin->pluginAbsolutePath)
        		

        	}
        }

	}

}